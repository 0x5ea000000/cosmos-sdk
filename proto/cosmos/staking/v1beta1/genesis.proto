syntax = "proto3";
package cosmos.staking.v1beta1;

option go_package = "github.com/cosmos/cosmos-sdk/x/staking/types";

import "gogoproto/gogo.proto";
import "cosmos/staking/v1beta1/staking.proto";
import "cosmos/staking/v1beta1/tx.proto";

// GenesisState defines the staking module's genesis state.
message GenesisState {
  // params defines all the paramaters of related to deposit.
  Params params = 1 [(gogoproto.nullable) = false];

  // last_total_power tracks the total amounts of bonded tokens recorded during
  // the previous end block.
  bytes last_total_power = 2 [
    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int",
    (gogoproto.moretags)   = "yaml:\"last_total_power\"",
    (gogoproto.nullable)   = false
  ];

  // last_validator_powers is a special index that provides a historical list
  // of the last-block's bonded validators.
  repeated LastValidatorPower last_validator_powers = 3
      [(gogoproto.moretags) = "yaml:\"last_validator_powers\"", (gogoproto.nullable) = false];

  // delegations defines the validator set at genesis.
  repeated Validator validators = 4 [(gogoproto.nullable) = false];

  // delegations defines the delegations active at genesis.
  repeated Delegation delegations = 5 [(gogoproto.nullable) = false];

  // unbonding_delegations defines the unbonding delegations active at genesis.
  repeated UnbondingDelegation unbonding_delegations = 6
      [(gogoproto.moretags) = "yaml:\"unbonding_delegations\"", (gogoproto.nullable) = false];

  // redelegations defines the redelegations active at genesis.
  repeated Redelegation redelegations = 7 [(gogoproto.nullable) = false];

  bool exported = 8;

  // added newly added queues
  repeated MsgEditValidator buffered_edit_validators = 9;
  repeated MsgDelegate buffered_delegations = 10;
  repeated MsgBeginRedelegate buffered_redelegations = 11;
  repeated MsgUndelegate buffered_undelegations = 12;

  // Current logic flow summary:
  // Current queues: "unbonding validator", "unbonding delegator", “redelegation"
  // Current Queue management
  // EndBlocker -> BlockValidatorUpdates -> DequeueAllMatureUBDQueue
  // EndBlocker -> BlockValidatorUpdates -> DequeueAllMatureRedelegationQueue
  // EndBlocker -> BlockValidatorUpdates -> UnbondAllMatureValidators 
  // EndBlocker -> BlockValidatorUpdates -> CompleteUnbonding -> RemoveUnbondingDelegation
  // EndBlocker -> BlockValidatorUpdates -> CompleteRedelegation -> RemoveRedelegation
  // BeginBlocker -> HandleValidatorSignature -> Jail
  // BeginBlocker -> HandleValidatorSignature -> Slash

  // Target logic flow summary:
  // Epoch -> BlockValidatorUpdates -> DequeueAllMatureUBDQueue
  // Epoch -> BlockValidatorUpdates -> DequeueAllMatureRedelegationQueue
  // Epoch -> BlockValidatorUpdates -> UnbondAllMatureValidators 
  // Epoch -> BlockValidatorUpdates -> CompleteUnbonding -> RemoveUnbondingDelegation
  // Epoch -> BlockValidatorUpdates -> CompleteRedelegation -> RemoveRedelegation
  // BeginBlocker -> HandleValidatorSignature -> Jail
  // BeginBlocker -> HandleValidatorSignature -> Slash

  // Current Msgs management
  // MsgUnjail -> instant validator update on condition met
  // MsgCreateValidator -> instant validator creation
  // MsgEditValidator -> instant validator update
  // MsgBeginRedelegate -> instant validator update and queue redelegation
  // MsgUndelegate -> instant pool balance update and queue undelegate
  // MsgDelegate -> instant delegation update
  // MsgWithdrawValidatorCommission -> instant
  // MsgWithdrawDelegatorReward -> instant

  // Target Msgs management
  // MsgUnjail -> queue validator update on condition met (BufferedMsgUnjailQueue)
  // MsgCreateValidator -> queue validator creation on condition met (BufferedMsgCreateValidatorQueue)
  // MsgEditValidator -> queue validator edit on condition met (BufferedMsgEditValidatorQueue)
  // MsgDelegate -> queue delegate (BufferedMsgDelegateQueue)
  // MsgBeginRedelegate -> queue redelegation (BufferedMsgRedelegationQueue) => move tokens between validators on epoch => After 3 weeks time, it should automatically remove redelegation entry for completion even though it's nott the end of epoch
  // MsgUndelegate -> queue undelegation (BufferedMsgUndelegateQueue) => move tokens to NotBondedPool and start unbonding period on epoch => After 3 weeks time, it should automatically unbond even though it’s not the end of epoch
  // MsgWithdrawValidatorCommission -> instant
  // MsgWithdrawDelegatorReward -> instant

  // The flow for an unbonding process would be:

  // 1. Submit MsgUnbond which adds it to DelegationChangeQueue
  // 2. Wait for end of Epoch
  // 3. Execute "BeginUnbonding", this adds it to UnbondingQueue
  // 4. Wait till end of Unbonding Period (3 weeks)
  // 5. Remove from UnbondingQueue

  // When a validator begins the unbonding process, it turns the validator into unbonding state instantly.
  // This is different than a specific delegator beginning to unbond. A validator beginning to unbond means that it's not in the set any more.
  // A delegator unbonding from a validator removes their delegation from the validator.

  // Cases that trigger unbonding process
  // - Validator undelegate can unbond more tokens than his minimum_self_delegation and it will automatically turn the validator into unbonding
  //   In this case, unbonding should start instantly.
  // - Validator miss blocks and get slashed
  // - Validator get slashed for double sign
  
  // The order of running buffered msgs on epoching could affect something?
  // e.g. MsgUnjail could happen later time than MsgDelegate and next Jail/Slash event.
  // e.g. MsgUnjail and MsgUndelegate could happen in different order. MsgUndelegate after MsgUnjail.
  // I think it won't affect anything, btw, here's current ordering of implementation in simapp.
  // 	app.mm.SetOrderBeginBlockers(
	// 	upgradetypes.ModuleName, minttypes.ModuleName, distrtypes.ModuleName, slashingtypes.ModuleName,
	// 	evidencetypes.ModuleName, stakingtypes.ModuleName, ibchost.ModuleName,
	// )
	// app.mm.SetOrderEndBlockers(crisistypes.ModuleName, govtypes.ModuleName, stakingtypes.ModuleName)

  // Changes to make for logic flow
  // BlockValidatorUpdates should be modified to ValidatorUpdates and should be called on Epoch
  // BeginBlocker -> HandleValidatorSignature run as it is and run ValidatorUpdates when it's updated on EndBlocker
  // to trigger tendermint validator set update instantly when Jail/Slash case.

  // Changes to make for Msgs flow
  // BufferMsgUnjail should be added to execute on next epoch: Add when condition met
  // BufferMsgCreateValidator should be added: send from user account to NotBondedPool and queue action
  // BufferMsgEditValidator should be added: queue action
  // BufferMsgDelegate should be added: queue action
  // BufferMsgBeginRedelegate should be added: queue action
  // BufferMsgUnDelegate should be added: queue action
}

// LastValidatorPower required for validator set update logic.
message LastValidatorPower {
  option (gogoproto.equal)           = false;
  option (gogoproto.goproto_getters) = false;

  // address is the address of the validator.
  string address = 1;

  // power defines the power of the validator.
  int64 power = 2;
}

// Development plan
// — Implement changes for Msgs flow
// - - Check if MarshalAny/UnmarshalAny based serialization work (at least build error does not exist now)
// — — Discuss and fix feedback for Msgs flow
// — — Implement TODOs on the PR #46
// — Implement logic flow after queue action
// — — Review logic for Slashing/Jail and check/discuss how to update it
// — — Review logic for Epoch action and check if there could be a vulnerability from current implementation (mainly moving from Unbonded to Bonded process)
// — Implement CLI commands for querying
// — — BufferedValidators
// — — BufferedMsgCreateValidatorQueue, BufferedMsgEditValidatorQueue
// — — BufferedMsgUnjailQueue, BufferedMsgDelegateQueue, BufferedMsgRedelegationQueue, BufferedMsgUndelegateQueue
// — Fix existing tests / remove invalid tests
// — Write epoch related tests with new scenarios
// — — Simulation test is important for finding bugs [Ask Dev for questions) 
// — — I’d like it added as an invariant test for the simulator
// — — the simulator should check that the sum of all the queued delegations always equals the amount kept track in the data
// — — Staking/Slashing/Distribution module params are being modified by governance based on vote result instantly. We should test the effect.
// — — — Should test to see what would happen if max_validators is changed though, in the middle of an epoch
// — — we should define some new invariants that help check that everything is working smoothly with these new changes for 3 modules e.g. https://github.com/cosmos/cosmos-sdk/blob/master/x/staking/keeper/invariants.go
// — — we should count all the delegation changes that happen during the epoch, and then make sure that the resulting change at the end of the epoch is actually correct
// — — If the validator that I delegated to double signs at block 16, I should still get slashed instantly because even though I asked to unbond at 14, they still used my power at block 16, I should only be not liable for slashes once my power is stopped being used
// — — On the converse of this, I should still be getting rewards while my power is being used.  I shouldn’t stop receiving rewards until block 20